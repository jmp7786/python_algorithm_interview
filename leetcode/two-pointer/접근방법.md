### Two pointer 접근방법

Two Pointer 알고리즘은 주로 배열이나 문자열과 같은 선형 데이터 구조에서 원소를 찾거나, 특정 조건을 충족하는 부분 집합을 찾는 문제를 해결할 때 사용됩니다. 주어진 문제가 Two Pointer 유형인지 판단하기 위해 다음과 같은 기준을 확인해야 합니다:

- 판단:
  1. 선형 데이터 구조: 문제에서 주어진 데이터 구조가 배열이나 문자열과 같은 선형 데이터 구조인지 확인합니다. 
  2. 포인터 사용: 문제를 해결하기 위해 두 개의 포인터를 동시에 사용해야 하는지 확인합니다. 일반적으로 Two Pointer 알고리즘에서 한 포인터는 배열의 시작점을 가리키고, 다른 포인터는 배열의 끝점을 가리킵니다. 
  3. 포인터 이동: 문제에서 주어진 조건에 따라 포인터를 이동시켜야 하는지 확인합니다. 포인터는 일반적으로 서로의 방향으로 이동하며, 특정 조건을 충족할 때까지 이동합니다. 
  4. 특정 조건 충족: 문제가 특정 조건을 충족하는 부분 집합을 찾는 것과 관련이 있는지 확인합니다. 예를 들어, 주어진 합이나 차이를 갖는 쌍을 찾거나, 특정 값을 초과하지 않는 최장 부분 집합을 찾는 경우입니다. 
  5. 선형 시간 복잡도: Two Pointer 알고리즘을 적용할 수 있는 문제는 주로 선형 시간 복잡도(O(n))로 해결할 수 있는 문제입니다.

- 접근
    ```
    문제: 주어진 정렬된 배열에서 두 원소의 합이 주어진 타겟 값이 되는 원소 쌍을 찾으세요.
    예시:
        입력: arr = [1, 2, 4, 7, 11, 15], target = 9
        출력: (2, 7) 또는 인덱스 (1, 3)```
    ```
    ```
    def two_sum_sorted(arr, target):
         left, right = 0, len(arr) - 1

        while left < right:
            current_sum = arr[left] + arr[right]

            if current_sum == target:
                return (left, right)  # 원소 쌍의 인덱스를 반환합니다.
            elif current_sum < target:
                left += 1
            else:
                right -= 1

        return None  # 쌍을 찾지 못한 경우 None을 반환합니다.

    arr = [1, 2, 4, 7, 11, 15]
    target = 9
    result = two_sum_sorted(arr, target)
    print(result)  # 출력: (1, 3)
    ```


### 노트 
1. 배열을 통해서 두가지의 컨디션을 다뤄야하면 접근한다.  
2. left와 right를 나눈다. while 혹은 for문을 통해서 loop를 돈다. 

정렬되지 않은 배열을 투포인터를 통해서 정렬할 수 있다. 
3개를 가지고 포인팅하는 문제도 있다. Dutch national flag 문제 

